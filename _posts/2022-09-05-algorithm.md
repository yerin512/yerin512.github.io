---
layout: post
title: 알고리즘 문제 풀기 Level1 "같은 숫자는 싫어"
subtitle: 배열 arr에서 연속적인 숫자 제거, 남은 수들을 return
categories: Algorithm
tags: [TIL, Algorithm]
---

어떻게 문제를 풀 것인가?
1. 문제에 대한 이해
우리가 풀어야 할 문제는 무엇인가?
  배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 동빈이의 큰 수의 
  법칙에 따른 결과를 출력하라.

주어진 자료는 무엇인가?
  배열의 특정한 인덱스에 해당하는 수가 연속해서 K번 초과해서 더해질 수 없다.
  배열이 주어진다.
  서로 다른 인덱스에 해당하는 수가 같은 경우에도 다른 것으로 간주한다. -> 왜 필요하지?
  배열이다.
    정렬가능하다.
    읽기
    탐색
    삽입
    수정
    삭제

조건은 무엇인가?
  입력으로 주어지는 K는 항상 M보다 작거나 같다.
  

우리가 문제를 풀기 위해 주어진 자료가 충분한가?
숨겨진 조건이나 자료가 있는가? 그렇다면 그 것을 다른 방법으로 해석해보라.


var list = [2, 4, 5, 4, 6];
var M = 8;
var K = 3;

2. 계획
  배열을 정렬한다. ssort
  가장 큰 수와 두 번째로 큰 수를 list[0], list[1]로 뽑아낸다.
  K <= M 일 경우에만 식이 수행되도록 조건문을 건다.
  더하는 횟수는 M번이어야한다. (반복문)
  변수 result에 결과값을 저장한다.


 K번까지만 가장 큰 수를 더할수있다.
  result += 가장 큰 수 * K
  m = m - 1
 횟수를 빼주고 K번이 넘으면
 두 번째로 큰 수를 한 번 더해준다.
 그 후 다시 K를 원상복구 시켜서 또 반복시킨다.

 
전에 비슷한 문제를 알고 있는가?
	
이 문제를 푸는데 있어서 유용하게 쓸 수 있는 지식은 무엇인가?
	ssort, 반복되는 수열의 길이 구하기
비슷한 문제를 풀어본 적이 있다면 그 것을 활용할 수 있는가?
	네!
만약 문제를 풀 수 없다면 문제를 더 단순하게 하기 위해서 주어진 조건을 버려보아라
	네
주어진 자료로부터 유용한 것을 이끌어 낼 수 있는가?
	아뇨
자료는 모두 사용했는가?
	서로 다른 인덱스에 해당하는 수가 같은 경우에도 다른 것으로 간주한다. (X)
조건을 모두 사용했는가?
	사용함
	
문제에 포함된 핵심적인 개념은 모두 고려했는가?
3. 실행
풀이 계획을 실행하고, 각 단계가 올바른지 점검하라.
4. 반성
문제를 다른 방식으로 해결할 수 있는가? 
	반복되는 수열을 이용하여 푼다면 훨씬 더 효율적으로 풀 수 있다.
결과나 방법을 어떤 다른 문제에 활용할 수 있는가?
	
어떻게 하면 더 효율적으로 문제를 해결할 수 있는가?
	반복문을 없애야한다.
어떻게 하면 더 효과적으로 문제를 해결할 수 있는가?
	반복문을 없애고 가장 큰 수가 등장하는 횟수와 두 번째로 큰 수가 더해지는 횟수를 구해야한다.


describe('큰 수의 법칙에 따른 결과를 출력하라.', () => {
    it('list가 [2, 4, 5, 4, 6], N = 5, M = 8, K =3일 경우', () => {
        expect(
            solution([
                [5, 8, 3],
                [2, 4, 5, 4, 6],
              ]),
            ).toBe(46);
    })
})




